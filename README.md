# 流媒体广播系统
## 一、包结构
在 include/proto.h 中定义了三个结构体。包括频道包和节目单包，节目单包中的内容是一个 msg_lisentry_st 结构体的数组。
一个节目单包如下图所示，为了能将节目单中各个频道的内容区分开，在 msg_lisentry_st 结构体中需要定义一个len来记录每个频道内容的长度(类似于TCP的粘包问题)。

图：节目单包
图：频道包

## 二、客户端的搭建

### 1. include/proto.h
#### (1) 关于TCP UDP数据包大小的限制
https://blog.csdn.net/caoshangpa/article/details/51530685

结论：在实际应用中
+ 用UDP协议发送时，用sendto函数最大能发送数据的长度为：65535-IP头(20) - UDP头(8) = 65507 字节
+ 用TCP协议发送时，由于TCP是数据流协议，因此不存在包大小的限制，这是指在使用send函数时，数据长度参数不受限制。而实际上，所指定的这段数据并不一定会一次发送出去，如果这段数据比较长，会被分段发送，如果比较短，可能会等待和下一次数据一起发送。

#### (2) __attribute__((packed)) 的作用
使用 __attribute__((packed)) 让编译器取消结构体在编译过程中的优化对齐，按照实际占用字节数进行对齐。

而在我们这里定义的结构体是作为通信协议传送的包，所以为了保证在不同平台下，结构体内的基本数据长度相同，就需要取消字节对齐。

#### (3) 关于C语言中的变长数组
https://blog.csdn.net/peng864534630/article/details/77620717

```C
struct msg_channel_st{
	chnid_t chnid;
	uint8_t data[0];
}__attribute__((packed));

```
在 msg_channel_st 这个结构体中，data是一个数组名，但该数组没有元素，实际上，data数组的真实地址紧随着结构体之后。（如果给这个结构体分配的内容大于这个结构体的实际大小，后面多余的部分就是这个data的内容），这种巧妙的方法可以实现变长数组。

有些编译器不允许使用data[0]这样的形式，所以在源码中，使用了data[1]。

**为什么不用指针代替这个数组呢？**
如果使用指针的话，它指向的是一块随机的内存，不能为结构体分配一段连续的内存。



